## 安装并简单使用GDB

### 预备工作

**安装**

```shell
sudo apt install gdb build-essential gcc
```

**配置**

```shell
# 格式配置
if ! grep -qi 'kernel.core_pattern' /etc/sysctl.conf; then
  sudo sh -c 'echo "kernel.core_pattern=core.%p.%u.%s.%e.%t" >> /etc/sysctl.conf'
  sudo sysctl -p
fi
ulimit -c unlimited

# 限制解除
sudo bash -c "cat << EOF > /etc/security/limits.conf
* soft core unlimited
* hard core unlimited
EOF"

cat /etc/security/limits.conf  # 出现下列提示时证明配置成功
#* soft core unlimited
#* hard core unlimited
```

### 测试demo

**编写测试文件**

```shell
cd ~
mkdir gdb-test
cd gdb-test
vim test.c
```

```c
# test.c

int actual_calc(int a, int b){
  int c;
  c=a/b;
  return 0;
}

int calc(){
  int a;
  int b;
  a=13;
  b=0;
  actual_calc(a, b);
  return 0;
}

int main(){
  calc();
  return 0;
}
```

**生成 Core Dump**

```shell
# 编译，注意一定要有 --ggdb 否则生成的 Core Dump 中不带 GDB 可以分析的错误信息
# 可以缩写为 gcc -g test.c -o test.o
gcc -ggdb test.c -o test.out

# 执行 test.out
./test.out
```

```shell
# 在执行 test.out 后查看当前目录
$ ls
core.2379.1000.8.test.out.1715087801  test.c  test.out
```

**选做**

```shell
# 设置在当前目录下创建 core（当不能在当前目录生成 core 时使用，如果能正常生成 core 则无需额外配置）
sudo bash -c "echo core.%p.%u.%s.%e.%t > /proc/sys/kernel/core_pattern"
cat /proc/sys/kernel/core_pattern

# 解除 core 文件大小限制
ulimit -c unlimited
ulimit -a

# 下列数值为 unlimited 证明配置成功
#core file size              (blocks, -c) unlimited
```

**trick：清屏操作**

```shell
clear	# 清屏
^L 		# 即 Ctrl + L 清屏
```

> **什么是 Core Dump ？**
>
> Core Dump 指的是在程序发生严重错误时，操作系统将程序运行时的内存状态和其他相关信息保存到文件中的过程。
>
> **为什么要引入 Core Dump ？**
>
> Core Dump 通常包含了程序执行时的内存快照、寄存器状态、堆栈信息等，用来帮助开发人员在发生错误时进行调试和排查问题。
>
> **Linux 什么时候由谁生成 Core Dump ？**
>
> 在Linux中，当一个程序因为诸如段错误、内存访问违例等严重错误而崩溃时，操作系统会生成一个Core Dump文件。这个文件通常会被命名为`core`，保存在程序崩溃的当前工作目录下。
>
> 生成Core Dump文件的操作是由操作系统处理的，通常是通过内核提供的相关机制来实现的。在Linux中，可以通过配置 ulimit 和 /proc 文件系统中的一些参数来控制Core Dump文件的生成行为。
>
> **怎么分析 Core Dump ？**
>
> 分析Core Dump文件通常需要使用调试工具，比如GDB（GNU调试器）。通过加载Core Dump文件到GDB中，可以查看程序崩溃时的堆栈信息、寄存器状态等，并尝试重现并解决问题。

**使用 GDB 分析 Core Dump**

```shell
# 注意参数是 .out 文件和 Core Dump
gdb ./test.out core.<p>.<u>.<s>.<e>.<t>
```

**Backtracing**

```shell
# 列举所有帧信息
bt # bt 是 backtracing 的缩写
```

**Frame Inspection**

```shell
# 查看要分析的帧
f <n> # f 是 frame 的缩写

# 查看帧对应语句的源码附近的源码，默认显示 10 行
list # list 可简写为 l，容易与 1 看混，所以后续不用缩写

# 打印变量 a 的值
p a # p 是 print 的缩写
```

**调用gdb调试**

```shell
lc@dust:~/learning-c$ gdb ./test.out ./core.2379.1000.8.test.out.1715087801 
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./test.out...
[New LWP 2379]

warning: Section `.reg-xstate/2379' in core file too small.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `./test.out'.
Program terminated with signal SIGFPE, Arithmetic exception.

warning: Section `.reg-xstate/2379' in core file too small.
#0  0x000056a44cb0413b in actual_calc (a=13, b=0) at test.c:3
--Type <RET> for more, q to quit, c to continue without paging--
3               c=a/b;
```

> 此次warning可以暂时忽略不计

```shell
# 列举帧信息
(gdb) bt
#0	0x000056a44cb0413b in actual_calc (a=13, b=0) at test.c:3
#1	0x000056a44cb04171 in calc () at test.c:12
#2	0x000056a44cb0418a in main () at test.c:17
```

```shell
# 查看帧信息
(gdb) f 0
#0  0x000056a44cb0413b in actual_calc (a=13, b=0) at test.c:3
3               c=a/b;
(gdb) list 
1       int actual_calc(int a, int b){
2               int c;
3               c=a/b;
4               return 0;
5       }
6
7       int calc(){
8               int a;
9               int b;
10              a=13;
(gdb) p a
$6 = 13
(gdb) p b
$7 = 0
(gdb) p c
$8 = 257
# 注意，我们已经定义了变量c，但还没有给它一个初始值
# 因此，c实际上是未定义的（而且它还没有被等式c=a/b填充，因为那个等式失败了）
# 结果值很可能是从变量c所分配的某个地址空间读取的（而那个内存空间还没有初始化/清除）

(gdb) f 1
#1  0x000056a44cb04171 in calc () at test.c:12
12              actual_calc(a, b);
(gdb) list
7       int calc(){
8               int a;
9               int b;
10              a=13;
11              b=0;
12              actual_calc(a, b);
13              return 0;
14      }
15
16      int main(){
(gdb) p a
$9 = 13
(gdb) p b
$10 = 0
(gdb) p c
No symbol "c" in current context.
(gdb) p a/b
Division by zero
# c未被定义，a/b中0作除数

(gdb) f 2
#2  0x000056a44cb0418a in main () at test.c:17
17              calc();
(gdb) list
12              actual_calc(a, b);
13              return 0;
14      }
15
16      int main(){
17              calc();
18              return 0;
19      }
(gdb) p a
No symbol "a" in current context.
(gdb) p b
No symbol "b" in current context.
(gdb) p c
No symbol "c" in current context.
```

上述可见，帧序号体现调用顺序，帧序号越小，表示其所在的调用层次越深

## 详细分析

### 单步执行和跟踪函数调用

**给出函数调试实例**

```c
#include<stadio.h>
int add_range(int low, int high){
    int i, sum;
    for(i = low; i <= high; i++)
        sum = sum + i;
    return sum;
}

int main(void){
    int result[100];
    result[0] = add_range(1, 10);
    result[1] = add_range(1, 100);
    printf("result[0]=%d\nresult[1]=%d\n", result[0], result[1]);
    return 0;
}
```

```c
result[0]=55
result[1]=5105
```

第一个结果正确，但第二个结果显然错误，既然第一个结果正确，那说明程序逻辑没有问题，我们应该怀疑是数据出了错，经验丰富的同学可以很快找出错误原因：局部变量`i`和`sum`没有初始化。那我们试试看用gdb来进行调试。

在编译时需要加上`-g`选项，这样生成的可执行文件才能用gdb进行源码级调试，（详细请RTFM）

```shell
$ gcc -g main.c -o main
$ gdb main
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from main...
(gdb)
```

> -g  
>
> Produce debugging information in the operating system's native format (stabs, COFF, XCOFF, or DWARF).  GDB can work with this debugging information.

`-g`选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。gdb提供一个类似Shell的命令行环境，上面的`(gdb)`就是提示符，在这个提示符下输入`help`可以查看命令的类别：

```shell
(gdb) help
List of classes of commands:

aliases -- User-defined aliases of other commands.
breakpoints -- Making program stop at certain points.
data -- Examining data.
files -- Specifying and examining files.
internals -- Maintenance commands.
obscure -- Obscure features.
running -- Running the program.
stack -- Examining the stack.
status -- Status inquiries.
support -- Support facilities.
text-user-interface -- TUI is the GDB text based interface.
tracepoints -- Tracing of program execution without stopping the program.
user-defined -- User-defined commands.

Type "help" followed by a class name for a list of commands in that class.
Type "help all" for the list of all commands.
Type "help" followed by command name for full documentation.
Type "apropos word" to search for commands related to "word".
Type "apropos -v word" for full documentation of commands related to "word".
Command name abbreviations are allowed if unambiguous.
```

当然，也可以进一步查看某一类别中有哪些命令，例如查看files类别下有哪些命令可用：

```shell
(gdb) help files
Specifying and examining files.

List of commands:

add-symbol-file -- Load symbols from FILE, assuming FILE has been dynamically loaded.
add-symbol-file-from-memory -- Load the symbols out of memory from a dynamically loaded object file.
cd -- Set working directory to DIR for debugger.
core-file -- Use FILE as core dump for examining memory and registers.
directory -- Add directory DIR to beginning of search path for source files.
edit -- Edit specified file or function.
exec-file -- Use FILE as program for getting contents of pure memory.
file -- Use FILE as program to be debugged.
forward-search, fo, search -- Search for regular expression (see regex(3)) from last line listed.
generate-core-file, gcore -- Save a core file with the current state of the debugged process.
list, l -- List specified function or line.
load -- Dynamically load FILE into the running program.
nosharedlibrary -- Unload all shared object library symbols.
path -- Add directory DIR(s) to beginning of search path for object files.
pwd -- Print working directory.
remote -- Manipulate files on the remote system.
remote delete -- Delete a remote file.
remote get -- Copy a remote file to the local system.
remote put -- Copy a local file to the remote system.
remove-symbol-file -- Remove a symbol file added via the add-symbol-file command.
reverse-search, rev -- Search backward for regular expression (see regex(3)) from last line listed.
section -- Change the base address of section SECTION of the exec file to ADDR.
sharedlibrary -- Load shared object library symbols for files matching REGEXP.
symbol-file -- Load symbol table from executable file FILE.

Type "help" followed by command name for full documentation.
Type "apropos word" to search for commands related to "word".
Type "apropos -v word" for full documentation of commands related to "word".
Command name abbreviations are allowed if unambiguous.
```

试试用`list`命令从第一行开始列出源码

```shell
(gdb) list 1
1	#include<stdio.h>
2	
3	int add_range(int low, int high){
4		int i, sum;
5		for(i = low; i <= high; i++)
6			sum = sum + i;
7		return sum;
8	}
9	
10	int main(void){
```

> list [file:]function
>            type the text of the program in the vicinity of where
>            it is presently stopped.

一次只列十行，若需要从11行开始继续列源码可以键入

```shell
(gdb) list
```

也可以直接敲回车（gdb提供功能：在提示符下直接敲回车表示重复上一行命令）

```shell
(gdb) <Enter>
11		int result[100];
12		result[0] = add_range(1, 10);
13		result[1] = add_range(1, 100);
14		printf("result[0]=%d\nesult[1]=%d\n", result[0], result[1]);
15	
16		return 0;
17	}
```

gdb常用命令有简写形式，如`list`可简写为`l`，要列出一个函数的源码也可用函数名做参数：

```shell
(gdb) l add_range 
1	#include<stdio.h>
2	
3	int add_range(int low, int high){
4		int i, sum;
5		for(i = low; i <= high; i++)
6			sum = sum + i;
7		return sum;
8	}
9	
10	int main(void){
```

退出gdb调试环境：

```shell
(gdb) quit # or q
```

gdb的参数是可执行文件`main`，我们可以测试一下将源码改名或移动到其他地方再用gdb调试，这样就列不出源码了

```shell
$ mv main.c mian.c
$ gdb main
...
(gdb) l
1	main.c: No such file or directory.
```

由此可见，gcc的`-g`选项并不是把源码嵌入到可执行文件中，在调试时也需要源码。把源码恢复后我们继续调试。首先用`start`命令开始执行程序

```shell
(gdb) start
Temporary breakpoint 1 at 0x11a5: file main.c, line 10.
Starting program: /home/lc/learning-c/main 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Temporary breakpoint 1, main () at main.c:10
10      int main(void){
```

>start
>​	Start the debugged program stopping at the beginning of the main procedure.

> run [arglist]
>            Start your program (with arglist, if specified).

> gdb调试器提供了多种方式来启动目标程序，其中最常用的就是`run`指令，其次为`start`指令。也就是说，`run`和`start`指令都可以用来在gdb调试器中启动程序，它们之间的区别是：
>
> 1、默认情况下，`run` 指令会一直执行程序，直到执行结束。如果程序中手动设置有断点，则`run`指令会执行程序至第一个断点处；
>
> 2、`start`指令会执行程序至 main() 主函数的起始位置，即在 main() 函数的第一行语句处停止执行（该行代码尚未执行）。
>
> 即：可以这样理解，使用`start`指令启动程序，完全等价于先在 main() 主函数起始位置设置一个断点，然后再使用`run`指令启动程序。另外，程序执行过程中使用`run`或者`start`指令，表示的是重新启动程序。

gdb停在main函数中变量定义之后的第一条语句处等待我们发命令，gdb列出的这条语句是即将执行的下一条语句，我们可以使用`next`命令（or `n`）控制这些语句一条一条执行：

```shell
(gdb) n
12              result[0] = add_range(1, 10);
(gdb) <Enter>
13              result[1] = add_range(1, 100);
(gdb) <Enter>
14              printf("result[0]=%d\nesult[1]=%d\n", result[0], result[1]);
(gdb) <Enter>
result[0]=55
esult[1]=5105
16              return 0;

```

> next
>            Execute next program line (after stopping); step over
>            any function calls in the line.

用`n`命令依次执行两行赋值语句和一行打印语句，在执行打印语句时结果立刻打出来了，然后停在`return`语句之前等待我们发命令。虽然我们完全控制了程序的执行，但仍然看不出哪里错了，因为错误不在`main`函数中而在`add_range`函数中，现在用`start`命令重新来过，这次用`step`命令（简写为`s`）钻进`add_range`函数中去跟踪执行：

```shell
(gdb) start
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Temporary breakpoint 3 at 0x5555555551a5: file main.c, line 10.
Starting program: /home/lc/learning-c/main 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Temporary breakpoint 3, main () at main.c:10
10      int main(void){
(gdb) n
12              result[0] = add_range(1, 10);
(gdb) s
add_range (low=1, high=10) at main.c:5
5               for(i = low; i <= high; i++)
```

> step
>            Execute next program line (after stopping); step into
>            any function calls in the line.

这次停在了`add_range`函数中变量定义之后的第一条语句处。在函数中有几种查看状态的办法，`backtrace`命令（简写为`bt`）可以查看函数调用的栈帧：

```shell
(gdb) bt
#0  add_range (low=1, high=10) at main.c:5
#1  0x00005555555551c3 in main () at main.c:12
```

> bt 	Backtrace: display the program stack. 

可见当前的`add_range`函数是被`main`函数调用的，`main`传进来的参数是`low=1, high=10`。`main`函数的栈帧编号为1，`add_range`的栈帧编号为0。现在可以用`info`命令（简写为`i`）查看`add_range`函数局部变量的值：

```shell
(gdb) i locals
i = 0
sum = 0
```

> info, inf, i
> 	Generic command for showing things about the program being debugged.

如果想查看`main`函数当前局部变量的值也可以做到，先用`frame`命令（简写为`f`）选择1号栈帧然后再查看局部变量：

```shell
(gdb) f 1
#1  0x00005555555551c3 in main () at main.c:12
12              result[0] = add_range(1, 10);
(gdb) i locals
result = {0 <repeats 28 times>, 16777216, 0, 32768, 0, 12582912, 0, 8, 0, 64, 0, 8, 0, 64, 0, 0, 0, -1, -1, 0, 0, 0, 0, 25, 80, 2, 
  0, 6, -2147483648, 0 <repeats 14 times>, -134330144, 32767, 13, 0, 1, 0, 1, 0, 1, 0, 1431650368, 21845, -134338500, 32767, 3376, 
  0, -7495, 32767, -134475776, 32767, 16777216, 257, 2, 0, 126614527, 0, -7479, 32767, 100, 0}
```

> frame, f
> 	Select and print a stack frame.

注意到`result`数组中有很多元素具有杂乱无章的值，我们知道未经初始化的局部变量具有不确定的值。到目前为止一切正常。用`s`或`n`往下走几步，然后用`print`命令（简写为`p`）打印出变量`sum`的值：

```shell
(gdb) s
6                       sum = sum + i;
(gdb) 
5               for(i = low; i <= high; i++)
(gdb) 
6                       sum = sum + i;
(gdb) 
5               for(i = low; i <= high; i++)
(gdb) p sum
$1 = 3
```

> print expr
> ​	Display the value of an expression.

第一次循环`i`是1，第二次循环`i`是2，加起来是3，没错。这里的`$1`表示`gdb`保存着这些中间结果，`$`后面的编号会自动增长，在命令中可以用`$1`、`$2`、`$3`等编号代替相应的值。由于我们本来就知道第一次调用的结果是正确的，再往下跟也没意义了，可以用`finish`命令让程序一直运行到从当前函数返回为止：

```shell
(gdb) finish
Run till exit from #0  add_range (low=1, high=10) at main.c:5
main () at main.c:12
12		result[0] = add_range(1, 10);
Value returned is $2 = 55
```

返回值是55，当前正准备进行赋值操作，用s命令赋值，然后查看result数组：

```shell
(gdb) s
13		result[1] = add_range(1, 100);
(gdb) p result
$3 = {55, 0 <repeats 23 times>, 12582912, 0, 2112, 0, 16777216, 0, 32768, 0, 
  12582912, 0, 8, 0, 64, 0, 8, 0, 64, 0, 0, 0, -1, -1, 0, 0, 2, 0, 6, 
  -2147483648, 0 <repeats 18 times>, -134330144, 32767, 13, 0, 1, 0, 1, 0, 1, 
  0, 1431650368, 21845, -134338500, 32767, 3376, 0, -7383, 32767, -134475776, 
  32767, 16777216, 257, 2, 0, 126614527, 0, -7367, 32767, 100, 0}
```

第一个值55确实赋给了`result`数组的第0个元素。下面用`s`命令进入第二次`add_range`调用，进入之后首先查看参数和局部变量：

```shell
(gdb) s
add_range (low=1, high=100) at main.c:5
5		for(i = low; i <= high; i++)
(gdb) bt
#0  add_range (low=1, high=100) at main.c:5
#1  0x00005555555551d8 in main () at main.c:13
(gdb) i locals
i = 11
sum = 55
```

由于局部变量`i`和`sum`没初始化，所以具有不确定的值，又由于两次调用是挨着的，`i`和`sum`正好取了上次调用时的值。`i`的初值不是0倒没关系，在`for`循环中会赋值为0的，但`sum`如果初值不是0，累加得到的结果就错了。好了，我们已经找到错误原因，可以退出`gdb`修改源代码了。如果我们不想浪费这次调试机会，可以在`gdb`中马上把`sum`的初值改为0继续运行，看看这一处改了之后还有没有别的Bug：

```shell
(gdb) set var sum=0
(gdb) finish
Run till exit from #0  add_range (low=1, high=100) at main.c:5
main () at main.c:13
13		result[1] = add_range(1, 100);
Value returned is $4 = 5050
(gdb) n
14		printf("result[0]=%d\nesult[1]=%d\n", result[0], result[1]);
(gdb) 
result[0]=55
esult[1]=5050
16		return 0;
```

这样结果就对了。修改变量的值除了用`set`命令之外也可以用`print`命令，因为`print`命令后面跟的是表达式，而我们知道赋值和函数调用也都是表达式，所以也可以用`print`命令修改变量的值或者调用函数：

```shell
(gdb) p result[2]=33
$5 = 33
(gdb) p printf("result[2]=%d\n", result[2])
result[2]=33
$6 = 13
```

`printf`的返回值表示实际打印的字符数，所以`$6`的结果是13。

总结一下本节用到的`gdb`命令：

|        命令         |                          描述                          |
| :-----------------: | :----------------------------------------------------: |
|  backtrace（或bt）  |                 查看各级函数调用及参数                 |
|       finish        |     连续运行到当前函数返回为止，然后停下来等待命令     |
| frame（或f） 帧编号 |                        选择栈帧                        |
| info（或i） locals  |                查看当前栈帧局部变量的值                |
|     list（或l）     |      列出源代码，接着上次的位置往下列，每次列10行      |
|      list 行号      |                列出从第几行开始的源代码                |
|     list 函数名     |                  列出某个函数的源代码                  |
|     next（或n）     |                     执行下一行语句                     |
|    print（或p）     | 打印表达式的值，通过表达式可以修改变量的值或者调用函数 |
|     quit（或q）     |                   退出`gdb`调试环境                    |
|       set var       |                      修改变量的值                      |
|        start        |   开始执行程序，停在`main`函数第一行语句前面等待命令   |
|     step（或s）     |      执行下一行语句，如果有函数调用则进入到函数中      |

### 断点

**断点调试是实例**

```shell
#include<stdio.h>

int main(){
	int sum = 0, i = 0;
	char input[5];
	
	while(1) {
		scanf("%s", input);
		for(i = 0; input[i] != '\0'; i++)
			sum = sum * 10 + input[i] - '0';
		printf("input=%d\n", sum);
	}
	return 0;
}
```

该程序的作用是：首先从键盘读入一串数字存到字符数组`input`中，然后转换成整型存到`sum`中，然后打印出来，一直这样循环下去。`scanf("%s", input);`这个调用的功能是等待用户输入一个字符串并回车，`scanf`把其中第一段非空白（非空格、Tab、换行）的字符串保存到`input`数组中，并自动在末尾添加`'\0'`。接下来的循环从左到右扫描字符串并把每个数字累加到结果中，例如输入是`"2345"`，则循环累加的过程是`(((0*10+2)*10+3)*10+4)*10+5=2345`。注意字符型的`'2'`要减去`'0'`的ASCII码才能转换成整数值2。下面编译运行程序看看有什么问题：

```shell
$ gcc main.c -g -o main
$ ./main 
123
input=123
234
input=123234
^C		#(Ctrl-C退出程序)
$
```

又是这种现象，第一次是对的，第二次就不对。可是这个程序我们并没有忘了赋初值，不仅`sum`赋了初值，连不必赋初值的i都赋了初值。读者先试试只看代码能不能看出错误原因。下面来调试：

```shell
$ gdb main
...
(gdb) start
Temporary breakpoint 1 at 0x1175: file main.c, line 4.
Starting program: /home/lc/learning-c/main 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Temporary breakpoint 1, main () at main.c:4
4	{
(gdb) n
5            int sum = 0, i = 0;
```

有了上一次的经验，`sum`被列为重点怀疑对象，我们可以用`display`命令使得每次停下来的时候都显示当前`sum`的值，然后继续往下走：

```shell
(gdb) n
9			scanf("%s", input);
1: sum = 0
(gdb) 
123
10			for (i = 0; input[i] != '\0'; i++)
1: sum = 0
```

`undisplay` 命令可以取消跟踪显示，变量 `sum` 的编号是1，可以用 `undisplay 1` 命令取消它的跟踪显示。这个循环应该没有问题，因为上面第一次输入时打印的结果是正确的。如果不想一步一步走这个循环，可以用 `break` 命令（简写为 `b` ）在第9行设一个断点（Breakpoint）：

```shell
(gdb) l
5		int sum = 0, i = 0;
6		char input[5];
7	
8		while (1) {
9			scanf("%s", input);
10			for (i = 0; input[i] != '\0'; i++)
11				sum = sum*10 + input[i] - '0';
12			printf("input=%d\n", sum);
13		}
14		return 0;
(gdb) b 9
Breakpoint 2 at 0x555555555192: file main.c, line 9.
```

`break` 命令的参数也可以是函数名，表示在某个函数开头设断点。现在用 `continue` 命令（简写为 `c` ）连续运行而非单步运行，程序到达断点会自动停下来，这样就可以停在下一次循环的开头：

```shell
(gdb) c
Continuing.
input=123

Breakpoint 2, main () at main.c:9
9			scanf("%s", input);
1: sum = 123
```

然后输入新的字符串准备转换：

```shell
(gdb) n
234
10			for (i = 0; input[i] != '\0'; i++)
1: sum = 123
```

问题暴露出来了，新的转换应该再次从0开始累加，而 `sum` 现在已经是123了，原因在于新的循环没有把 `sum`归零。可见断点有助于快速跳过没有问题的代码，然后在有问题的代码上慢慢走慢慢分析，“断点加单步”是使用调试器的基本方法。至于应该在哪里设置断点，怎么知道哪些代码可以跳过而哪些代码要慢慢走，也要通过对错误现象的分析和假设来确定，以前我们用 `printf` 打印中间结果时也要分析应该在哪里插入 `printf` ，打印哪些中间结果，调试的基本思路是一样的。一次调试可以设置多个断点，用 `info` 命令可以查看已经设置的断点：

```
(gdb) b 12
Breakpoint 3 at 0x5555555551eb: file main.c, line 12.
(gdb) i breakpoints 
Num     Type           Disp Enb Address            What
2       breakpoint     keep y   0x0000555555555192 in main at main.c:9
	breakpoint already hit 1 time
3       breakpoint     keep y   0x00005555555551eb in main at main.c:12
```

每个断点都有一个编号，可以用编号指定删除某个断点：

```shell
(gdb) delete breakpoints 2
(gdb) i breakpoints 
Num     Type           Disp Enb Address            What
3       breakpoint     keep y   0x00005555555551eb in main at main.c:12
```

有时候一个断点暂时不用可以禁用掉而不必删除，这样以后想用的时候可以直接启用，而不必重新从代码里找应该在哪一行设断点：

```shell
(gdb) disable breakpoints 3
(gdb) i breakpoints 
Num     Type           Disp Enb Address            What
3       breakpoint     keep n   0x00005555555551eb in main at main.c:12
(gdb) enable 3
(gdb) i breakpoints 
Num     Type           Disp Enb Address            What
3       breakpoint     keep y   0x00005555555551eb in main at main.c:12
(gdb) delete breakpoints 
Delete all breakpoints? (y or n) y
(gdb) i breakpoints 
No breakpoints or watchpoints.
```

**gdb** 的断点功能非常灵活，还可以设置断点在满足某个条件时才激活，例如我们仍然在循环开头设置断点，但是仅当 `sum` 不等于0时才中断，然后用 `run` 命令（简写为 `r` ）重新从程序开头连续运行：

```shell
(gdb) break 9 if sum != 0
Breakpoint 4 at 0x555555555192: file main.c, line 9.
(gdb) i breakpoints 
Num     Type           Disp Enb Address            What
4       breakpoint     keep y   0x0000555555555192 in main at main.c:9
	stop only if sum != 0
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/lc/learning-c/main 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
123
input=123

Breakpoint 4, main () at main.c:9
9			scanf("%s", input);
1: sum = 123
```

结果是第一次执行`scanf`之前没有中断，第二次却中断了。总结一下本节用到的`gdb`命令：

| 命令                       | 描述                                     |
| -------------------------- | ---------------------------------------- |
| break（或b） 行号          | 在某一行设置断点                         |
| break 函数名               | 在某个函数开头设置断点                   |
| break ... if ...           | 设置条件断点                             |
| continue（或c）            | 从当前位置开始连续运行程序               |
| delete breakpoints 断点号  | 删除断点                                 |
| display 变量名             | 跟踪查看某个变量，每次停下来都显示它的值 |
| disable breakpoints 断点号 | 禁用断点                                 |
| enable 断点号              | 启用断点                                 |
| info（或i） breakpoints    | 查看当前设置了哪些断点                   |
| run（或r）                 | 从头开始连续运行程序                     |
| undisplay 跟踪显示号       | 取消跟踪显示                             |

### 观察点



### 段错误







## Related Linux Tutorials:

* [How to Debug Bash Scripts](https://linuxconfig.org/how-to-debug-bash-scripts)
* [GDB debugging tutorial for beginners](https://linuxconfig.org/gdb-debugging-tutorial-for-beginners)