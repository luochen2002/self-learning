## 安装并简单使用GDB

### 预备工作

**安装**

```shell
sudo apt install gdb build-essential gcc
```

**配置**

```shell
# 格式配置
if ! grep -qi 'kernel.core_pattern' /etc/sysctl.conf; then
  sudo sh -c 'echo "kernel.core_pattern=core.%p.%u.%s.%e.%t" >> /etc/sysctl.conf'
  sudo sysctl -p
fi
ulimit -c unlimited

# 限制解除
sudo bash -c "cat << EOF > /etc/security/limits.conf
* soft core unlimited
* hard core unlimited
EOF"

cat /etc/security/limits.conf  # 出现下列提示时证明配置成功
#* soft core unlimited
#* hard core unlimited
```

### 测试demo

**编写测试文件**

```shell
cd ~
mkdir gdb-test
cd gdb-test
vim test.c
```

```c
# test.c

int actual_calc(int a, int b){
  int c;
  c=a/b;
  return 0;
}

int calc(){
  int a;
  int b;
  a=13;
  b=0;
  actual_calc(a, b);
  return 0;
}

int main(){
  calc();
  return 0;
}
```

**生成 Core Dump**

```shell
# 编译，注意一定要有 --ggdb 否则生成的 Core Dump 中不带 GDB 可以分析的错误信息
# 可以缩写为 gcc -g test.c -o test.o
gcc -ggdb test.c -o test.out

# 执行 test.out
./test.out
```

```shell
# 在执行 test.out 后查看当前目录
$ ls
core.2379.1000.8.test.out.1715087801  test.c  test.out
```

**选做**

```shell
# 设置在当前目录下创建 core（当不能在当前目录生成 core 时使用，如果能正常生成 core 则无需额外配置）
sudo bash -c "echo core.%p.%u.%s.%e.%t > /proc/sys/kernel/core_pattern"
cat /proc/sys/kernel/core_pattern

# 解除 core 文件大小限制
ulimit -c unlimited
ulimit -a

# 下列数值为 unlimited 证明配置成功
#core file size              (blocks, -c) unlimited
```

**trick：清屏操作**

```shell
clear	# 清屏
^L 		# 即 Ctrl + L 清屏
```

> **什么是 Core Dump ？**
>
> Core Dump 指的是在程序发生严重错误时，操作系统将程序运行时的内存状态和其他相关信息保存到文件中的过程。
>
> **为什么要引入 Core Dump ？**
>
> Core Dump 通常包含了程序执行时的内存快照、寄存器状态、堆栈信息等，用来帮助开发人员在发生错误时进行调试和排查问题。
>
> **Linux 什么时候由谁生成 Core Dump ？**
>
> 在Linux中，当一个程序因为诸如段错误、内存访问违例等严重错误而崩溃时，操作系统会生成一个Core Dump文件。这个文件通常会被命名为`core`，保存在程序崩溃的当前工作目录下。
>
> 生成Core Dump文件的操作是由操作系统处理的，通常是通过内核提供的相关机制来实现的。在Linux中，可以通过配置 ulimit 和 /proc 文件系统中的一些参数来控制Core Dump文件的生成行为。
>
> **怎么分析 Core Dump ？**
>
> 分析Core Dump文件通常需要使用调试工具，比如GDB（GNU调试器）。通过加载Core Dump文件到GDB中，可以查看程序崩溃时的堆栈信息、寄存器状态等，并尝试重现并解决问题。

**使用 GDB 分析 Core Dump**

```shell
# 注意参数是 .out 文件和 Core Dump
gdb ./test.out core.<p>.<u>.<s>.<e>.<t>
```

**Backtracing**

```shell
# 列举所有帧信息
bt # bt 是 backtracing 的缩写
```

**Frame Inspection**

```shell
# 查看要分析的帧
f <n> # f 是 frame 的缩写

# 查看帧对应语句的源码附近的源码，默认显示 10 行
list # list 可简写为 l，容易与 1 看混，所以后续不用缩写

# 打印变量 a 的值
p a # p 是 print 的缩写
```

**调用gdb调试**

```shell
lc@dust:~/learning-c$ gdb ./test.out ./core.2379.1000.8.test.out.1715087801 
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./test.out...
[New LWP 2379]

warning: Section `.reg-xstate/2379' in core file too small.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `./test.out'.
Program terminated with signal SIGFPE, Arithmetic exception.

warning: Section `.reg-xstate/2379' in core file too small.
#0  0x000056a44cb0413b in actual_calc (a=13, b=0) at test.c:3
--Type <RET> for more, q to quit, c to continue without paging--
3               c=a/b;
```

> 此次warning可以暂时忽略不计

```shell
# 列举帧信息
(gdb) bt
#0	0x000056a44cb0413b in actual_calc (a=13, b=0) at test.c:3
#1	0x000056a44cb04171 in calc () at test.c:12
#2	0x000056a44cb0418a in main () at test.c:17
```

```shell
# 查看帧信息
(gdb) f 0
#0  0x000056a44cb0413b in actual_calc (a=13, b=0) at test.c:3
3               c=a/b;
(gdb) list 
1       int actual_calc(int a, int b){
2               int c;
3               c=a/b;
4               return 0;
5       }
6
7       int calc(){
8               int a;
9               int b;
10              a=13;
(gdb) p a
$6 = 13
(gdb) p b
$7 = 0
(gdb) p c
$8 = 257
# 注意，我们已经定义了变量c，但还没有给它一个初始值
# 因此，c实际上是未定义的（而且它还没有被等式c=a/b填充，因为那个等式失败了）
# 结果值很可能是从变量c所分配的某个地址空间读取的（而那个内存空间还没有初始化/清除）

(gdb) f 1
#1  0x000056a44cb04171 in calc () at test.c:12
12              actual_calc(a, b);
(gdb) list
7       int calc(){
8               int a;
9               int b;
10              a=13;
11              b=0;
12              actual_calc(a, b);
13              return 0;
14      }
15
16      int main(){
(gdb) p a
$9 = 13
(gdb) p b
$10 = 0
(gdb) p c
No symbol "c" in current context.
(gdb) p a/b
Division by zero
# c未被定义，a/b中0作除数

(gdb) f 2
#2  0x000056a44cb0418a in main () at test.c:17
17              calc();
(gdb) list
12              actual_calc(a, b);
13              return 0;
14      }
15
16      int main(){
17              calc();
18              return 0;
19      }
(gdb) p a
No symbol "a" in current context.
(gdb) p b
No symbol "b" in current context.
(gdb) p c
No symbol "c" in current context.
```

上述可见，帧序号体现调用顺序，==帧序号越小==，表示其所在的==调用层次越深==

## Related Linux Tutorials:

* [How to Debug Bash Scripts](https://linuxconfig.org/how-to-debug-bash-scripts)
* [GDB debugging tutorial for beginners](https://linuxconfig.org/gdb-debugging-tutorial-for-beginners)